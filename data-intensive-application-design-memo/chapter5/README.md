## レプリケーション

### リーダーとフォロワー

- 基本的にはレプリカはリーダー（書き込み）とフォロワー（読み込み）に分けることができる。 リーダーは変更データをレプリケーションログまたは変更ストリームの一部として全てのフォロワーに送信する。
  - このレプリケーションは非同期か同期的に行われるかは選択できる。
  - ただし、同期的に行うと、一つのノードが壊れると全体が死ぬので、一つを同期的、それ以外を非同期で行うことがある。
- フォロワーのセットアップ
  - snapshot をとり、新しいフォロワーに復元する
  - ログシークエンス番号や binlog coordinates を用いてデータを同期する
- ノード障害への対処
  - フォロワーの障害はキャッチアップリカバリ
    - フォロワーが復活次第、ログシークエンス番号から復帰する
  - リーダーの障害はファイルオーバー
    - リーダーに障害が起きたことの確認（タイムアウト）
    - リーダーの選出
  - ファイルオーバー時の起こりうること
    - 古いリーダーが受信してリプリケーションされなかったデータは破棄される。
      - データベース以外にストレージシステムを持つ場合に危険
      - MySQL の auto increment な primary key が同期されずに破棄されたが、Redis にはそれが存在してしまったので障害 -> GitHub
    - スプリットブレイン
- レプリケーションログ
  - write-ahead ログ
    - postgres
    - バイナリデータのみを送信。インデックスは後で構築
  - 論理ログレプリケーション
    - mysql

### レプリケーションラグにまつわる問題

- 通常運用であればラグは 1/n 秒程度で収まるので、気にする必要はない
  - ただし、限界で運用されている場合やネットワークに問題が発生している場合は異なる
- read-after-write 一貫性
  - 自分で投入した更新が必ず反映されていることを保証する。
    - 別ユーザーには保証しない
    - 投入したデータはリーダーから読みましょうよ
- モノトニック
  - 参照するフォロワーによっては時間差でデータのレプリケーションが遅れ、見えたはずのデータが見えないことがある
  - 同一のフォロワーから読み取りを行う
- 一貫性のあるプレフィックス読み取り
  - レプリケーション時に異なる順番でデータが保管されてしまうことがある。

### マルチリーダーレプリケーション

- 加わる複雑さに対するメリットが十分ではないので、あまり採用されないが、ユースケースとしては
  - マルチデータセンターの運用
    - 同一データセンター内のフォロワーとリーダー同士で同期する。
  - オフラインで運用されるクライアント
    - suica がこれだな
  - コラボレーティブな編集
    - google docs とか
- 書き込み衝突
  - 二つのリーダーが存在することで、ほぼ同時に同じデータを更新するとそれぞれのリーダーで別のデータになってしまう
  - 結果、収束しなくなってしまうので、同期できない。
  - 収束するには
    - version id に datetime や uuid を加え、その最大の値を採用する Last Write Win な方法でデータを書き込む
    - 基本的にシステマティックに解決する方法はないので、アプリケーションレイヤーでなんとかするしかない
  - カスタム衝突解決
    - 書き込み時にコードを実行する方法と読み込み時には複数バージョンが存在する場合がある
- トポロジー
  - all-to-all
  - 循環トポロジー
  - スタートポロジー
    - suica

### リーダーレスレプリケーション

- リーダーという概念を捨てて、どのレプリカも直接編集される可能性がある仕組みのこと。
  - Dynamo がこれなので Dynamo モデルともいう
- 高い可用性と低レイテンシーが求められ、古いバージョンのデータを読み込んだとしても耐えられる場合に有効
- 仕組み
  - 複数台存在するデータベースに複数台同時に Write/Read のリクエストを投げる
  - そのうち、後述のクオラムを満たす数のノードが OK と返す
  - このうちの差分は、読み取り修復（読み取り時に古い version を更新する）か、半エントロピー処理（差分を自動的に更新するバックグラウンド処理）で解消する。
- クオラム
  - 全体で n 個のレプリカがあり、書き込み時の対象を w 個、読み込み時の対象を r とする。
  - w + r > n である限りは確実に書き込み/読み込みは成功する
    - w + r - n の値が小さいと古いバージョンを読み込む可能性が高まる
- sloppy quorum
  - 耐障害性を高める
  - 書き込みを受け付けておき、到達可能な n 個のノードに書き込む（sloppy quorum）
