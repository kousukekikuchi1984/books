## パーティショニング

### パーティショニングとレプリケーション

- パーティショニングはレプリケーションと組み合わせられる。
- ただし、パーティショニングとレプリケーションは独立しているので本章ではレプリケーションは扱わない

### キー・バリューデータのパーティショニング

- パーティショニングの目的は読み込みと書き込みのスループット向上。
  - 一部に偏っているのを skew な状態といい、負荷が高いパーティションをホットスポットいう
- どのパーティションにデータを保管させるか？
  - キーの範囲
    - skew の可能性があるので、適切に rebalancing する必要があるかも
  - キーのハッシュ
    - ランダムに key を設定できるので、skew の可能性がない
    - 範囲のクエリ実行の効率が失われる
    - とはいえ、アプリケーションレイヤーで何らかの key を作成する場面に偏りがあれば、skew になる。

### パーティショニングとセカンダリインデックス

- セカンダリインデックスとは検索にするためのインデックスっぽい。
- ローカルインデックス
  - パーティーション内部において各々が独立したインデックスを持っている
  - 書き込みが早いが、検索時に全パーティションをみに行くので遅くなる
- グローバルインデックス
  - パーティーション全体のインデックスを作成する方法
  - 検索時には早いが書き込みが遅くなる。
    - とはいえ、パーティーションを閲覧する時間が二倍になるので、その部分は遅くなる
  - インデックス作成は非同期で行われる

### パーティションのリバランシング

- 要件など
  - ホットスポットが発生している時にその偏りを解消するのが目的
  - リバランシング中はデータベースは読み書きを受け付けなければならない。
  - なるべく移動されるデータは最小限にとどめ、なるべく高速に行う。
- 戦略
  - ハッシュの余剰
    - ほとんどのデータが移動するために、3 番目の要件を満たさないため、用いるべきではない。
  - パーティション数の固定
    - ノード数より多くのパーティションを作成しておき、1 つのノードに複数のパーティーションを作成しておく
    - 各ノードから一つづつパーティーションを新しいノードに移す
  - 動的なパーティショニング
    - partiition key の範囲によってパーティショニングを行う時に、その範囲を動的に移動させる。
  - ノードあたりのパーティション数を固定にする
    - ノードを追加した時にはデータをそれぞれ分散させる。
- 運用
  - DB によりけりだが、自動化はできる
  - ただし、それは大規模障害をうむ可能性があるので、リバランシングは人を介在させるほうが良い

### リクエストのルーティング

- 適切な接続先の判断はどうすれば良い（service discovery）
  - 各ノードに接続先情報を持つ
  - routing 層に接続先情報を持たせる
    - 最新な接続先情報を確実に持つことが重要。
    - ZooKeeper など、外部的に接続先情報を管理するしくみを使い、ルーティング層に通知する方法が使われる
  - クライアントが直接持つ
